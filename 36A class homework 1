/**
 * @author: Justin Chan ID: 923264059
 */

#include "Sequence.h"
#include <iostream>
#include <set>
#include <cctype>
#include <sstream>
#include <stdbool.h>

std::set<std::string> makeList(const std::string str);

Sequence::Sequence(void){
    desc = "";
    seq = "";
}
Sequence::Sequence(const std::string& desc_str, const std::string& seq_str){
    desc = desc_str;
    seq = seq_str;
}

std::string Sequence::findNextMutation(const Sequence& s, const int& pos) const{
    s.check();

    Sequence firstSeq = (*this);
    for(long unsigned int x = pos; x <= s.seq.length(); x++){
        if(firstSeq.seq[x] != s.seq[x]){
            std::string give = std::string(1, firstSeq.seq[x]) + static_cast<char>(x) + std::string(1, s.seq[x]);
            return give;
        }
    }
    return "no mutation found";
}

Sequence findMUM(const Sequence& s1, const Sequence& s2){

    s1.check();
    s2.check();

    std::set<std::string> list1 = makeList(s1.seq);
    std::set<std::string> list2 = makeList(s2.seq);
    std::cout << "made list" << std::endl;

    long unsigned int lengthOfMatch = 0;
    std::string longest = "";

    for(std::string part1 : list1){
        for(std::string part2 : list2){
            if(part1 == part2 && part1.length() > lengthOfMatch){
                longest = part1;
                lengthOfMatch = part1.length();
            }
        }
    }

    std::cout << "no error" << std::endl;

    list1.clear();
    list2.clear();  

    std::cout << "no error" << std::endl;
    if(lengthOfMatch > 0){
        std::string seq1Same = "pos1=" + std::to_string(s1.seq.find(longest)) + " pos2=" + std::to_string(s2.seq.find(longest));
        std::string seq2Same = s2.seq.substr(s2.seq.find(longest), lengthOfMatch);
        std::cout << "no error" << std::endl;
        return Sequence(seq1Same, seq2Same);
    }else{
        std::cout << "no error" << std::endl;
        return Sequence();
    }


}

std::set<std::string> makeList(const std::string str){
    //called and works

    std::set<std::string> allCombo;
    std::string temp = str.substr(str.find(']')+1);
    for(long unsigned int x = 0; x <= temp.length() - 20; x++){
        for(long unsigned int y = 20; y <= temp.length(); y++){
            allCombo.insert(temp.substr(x, y));
        }
    }
    return allCombo;
}


std::istream& operator>> ( std::istream& is, Sequence& s ){
    //works as intended
    std::string temp;
    bool work = true;
    while(work){
        if(std::getline(is, temp)){
            s.seq = s.seq + temp;
        }else{
            work = false;
        }
    }
    return is;
}

std::ostream& operator<< ( std::ostream& os, const Sequence& s ){
    if(s.desc == "" && s.seq == ""){
        os << "No MUM found";
        return os;
    }else if(s.desc == "" && s.seq != ""){
        os << s.seq;
        return os;
    }else{
        os << ">MUM " + s.desc + s.seq;
        return os;
    }
}

void Sequence::check(void) const{
    Sequence thing = *this;
    for(char character : thing.seq){
        if(!isalpha(character) && (character == '\0' && isalpha(thing.seq[thing.seq.find(character) + 1]))){
            throw std::invalid_argument("invalid character in sequence");
        }
    }
}
